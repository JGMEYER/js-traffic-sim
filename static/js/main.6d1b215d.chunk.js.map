{"version":3,"sources":["util/Direction.js","Components/RoadTile/RoadTile.js","Components/Grid/Grid.js","Components/Intersection/Intersection.js","util/collision/Rectangle.js","util/Graph.js","Components/TravelGraph/TravelGraph.js","Components/Vehicle/Vehicle.js","util/Random.js","Components/Traffic/Traffic.js","Components/RoadNetwork/RoadNetwork.js","settings/GlobalSettingsForm.js","App.js","reportWebVitals.js","index.js"],"names":["Direction","UP","RIGHT","DOWN","LEFT","Object","freeze","oppositeDirection","dir","parseInt","Error","RoadTileType","EMPTY","ALONE","UP_RIGHT","RIGHT_DOWN","DOWN_LEFT","UP_LEFT","UP_DOWN","RIGHT_LEFT","UP_RIGHT_DOWN","RIGHT_DOWN_LEFT","UP_DOWN_LEFT","UP_RIGHT_LEFT","UP_RIGHT_DOWN_LEFT","getSegmentDirectionsForRoadTileType","roadTileType","RoadTile","props","className","displayRoadTileDescriptor","type","RoadTileMatrix","rows","cols","innerArray","Array","r","c","this","neighbors","coords","keys","getNeighbors","length","wasAdded","numNeighbors","up","right","down","left","evaluateRoadTileType","updateTile","restrictToNeighbors","hasNeighbors","_updateNeighbors","Grid","e","preventDefault","buttons","addRoad","removeRoad","globalSettings","roadTileMatrix","roadTileDivs","push","onMouseDown","mouseDownHandler","onMouseOver","mouseOverHandler","onContextMenu","displayRoadTileDescriptors","get","React","Component","Intersection","vehicles","waitTimersMillisec","_dequeueOrder","_clearTimer","vehicle","direction","WAIT_TIME_DURATION","dequeuedVehicle","tickMillisec","timer","Math","max","i","shift","CLEAR_TIME_DURATION","_dequeue","Rectangle","centerX","centerY","w","h","angleRad","xOffset","yOffset","defaultVertices","x","y","vertices","rotateToAngleRad","p","x1","y1","x2","cos","sin","y2","x0","y0","map","v","center","_rotatePointAroundCenter","angleDeg","PI","min","maxX","minX","maxY","minY","top","RectangleCollider","a","b","normal_x","normal_y","j","sides","rect","_hasSeparatingAxis","RectangleComponent","style","position","backgroundColor","width","boundingWidth","height","boundingHeight","topLeft","clipPath","polygonStr","verticesStr","verticesAtOrigin","f","join","Graph","edges","val","name","Number","isInteger","TypeError","source","target","_checkIsPositiveInteger","hasOwnProperty","includes","filter","n","inDegree","outDegree","key","indexOf","splice","values","forEach","nodesAlongPath","Set","visited","stack","adjacent","add","curNode","pop","has","dist","previous","remaining","nodes","Infinity","shortestDist","u","idx","node","alt","path","unshift","serializedEdges","TravelNodeType","ENTER","EXIT","TravelNode","row","col","travelNodeType","id","count","getComputedStyle","document","documentElement","tileWidth","getPropertyValue","tileHeight","middleX","middleY","TravelIntersection","tileType","addTravelNodes","enterNodes","getSegmentDirections","exitNodes","TravelGraph","graph","intersections","String","newestKey","reduce","startNodeId","possibleNodeIds","from","alongPath","nodeId","floor","random","serializeEdges","endNodeId","shortestPath","insct","nDirection","_intraconnectRoads","neighbor","nR","nC","nInsct","_removeIntersectionIntraconnectedEdges","getNodesForSegment","exit","enter","nExit","nEnter","_addEdge","_removeNode","removeTravelNodes","addEdge","removeEdge","removeNode","segmentDirections","getEnterNodes","getExitNodes","_removeEdge","TravelEdge","exitNode","enterNode","TravelGraphComponent","travelGraph","displayTravelEdges","getEdges","edge","getNode","Vehicle","color","randomColor","prevTargetId","speedPerSec","frontCollider","waitingAtInsct","randPath","_getRandomPath","setPath","hasNode","randTarget","getRandomNodeAlongPath","getShortestPath","remainingSpeed","targetNode","dx","dy","distToNode","sqrt","pow","atan2","xVelocity","yVelocity","translate","addVehicleToInsct","setRandomPath","_moveTowardsTarget","prevTarget","_atInsct","travelNode","roadTile","VehicleComponent","onClick","console","log","displayVehicleColliders","Traffic","inscts","_addVehicleToInsct","bind","collidesWith","insctKey","enqueue","step","_vehicleInCollision","removeVehiclesAt","vehicleIn","resetRandomPath","TrafficComponent","traffic","RoadNetwork","useState","setRoadTileMatrix","setTravelGraph","setTraffic","Date","now","lastTimeMillisec","setLastTimeMillisec","rerender","newRoadTileMatrix","newTravelGraph","newTraffic","useEffect","intervalId","setInterval","hidden","curTimeMillisec","clearInterval","addTile","registerTravelIntersection","newestNode","getNewestNode","addVehicle","rerandomizeAllVehiclePaths","tileCanBeRemoved","removeVehiclesNear","unregisterTravelIntersection","removeTile","GlobalSettingsForm","onChange","setDisplayRoadTileDescriptors","checked","htmlFor","setDisplayTravelEdges","setDisplayVehicleColliders","App","setGlobalSettings","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.6d1b215d.chunk.js","sourcesContent":["export const Direction = {\n    UP: 0,\n    RIGHT: 1,\n    DOWN: 2,\n    LEFT: 3,\n}\nObject.freeze(Direction);\n\nexport const oppositeDirection = (dir) => {\n    const dirInt = parseInt(dir)\n    switch (dirInt) {\n        case Direction.UP:\n            return Direction.DOWN;\n        case Direction.RIGHT:\n            return Direction.LEFT;\n        case Direction.DOWN:\n            return Direction.UP;\n        case Direction.LEFT:\n            return Direction.RIGHT;\n        default:\n            throw new Error('Unknown direction provided');\n    }\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport './RoadTile.css';\nimport { Direction } from '../../util/Direction';\n\nexport const RoadTileType = {\n    // no tile\n    EMPTY: 0,\n    // no neighbors\n    ALONE: 1,\n    // one neighbor\n    UP: 2,\n    RIGHT: 3,\n    DOWN: 4,\n    LEFT: 5,\n    // two neighbors\n    UP_RIGHT: 6,  // ╚\n    RIGHT_DOWN: 7,  // ╔\n    DOWN_LEFT: 8,  // ╗\n    UP_LEFT: 9,  // ╝\n    UP_DOWN: 10,  // ║\n    RIGHT_LEFT: 11,  // ═\n    // three neighbors\n    UP_RIGHT_DOWN: 12,  // ╠\n    RIGHT_DOWN_LEFT: 13,  // ╦\n    UP_DOWN_LEFT: 14,  // ╣\n    UP_RIGHT_LEFT: 15,  // ╩\n    // four neighbors\n    UP_RIGHT_DOWN_LEFT: 16,  //  ╬\n};\nObject.freeze(RoadTileType);\n\nexport function getSegmentDirectionsForRoadTileType(roadTileType) {\n    switch (roadTileType) {\n        case RoadTileType.EMPTY:\n            return [];\n        case RoadTileType.ALONE:\n            return [];\n        case RoadTileType.UP:\n            return [Direction.UP];\n        case RoadTileType.RIGHT:\n            return [Direction.RIGHT];\n        case RoadTileType.DOWN:\n            return [Direction.DOWN];\n        case RoadTileType.LEFT:\n            return [Direction.LEFT];\n        case RoadTileType.UP_RIGHT:\n            return [Direction.UP, Direction.RIGHT];\n        case RoadTileType.RIGHT_DOWN:\n            return [Direction.RIGHT, Direction.DOWN];\n        case RoadTileType.DOWN_LEFT:\n            return [Direction.DOWN, Direction.LEFT];\n        case RoadTileType.UP_LEFT:\n            return [Direction.UP, Direction.LEFT];\n        case RoadTileType.UP_DOWN:\n            return [Direction.UP, Direction.DOWN];\n        case RoadTileType.RIGHT_LEFT:\n            return [Direction.RIGHT, Direction.LEFT];\n        case RoadTileType.UP_RIGHT_DOWN:\n            return [Direction.UP, Direction.RIGHT, Direction.DOWN];\n        case RoadTileType.RIGHT_DOWN_LEFT:\n            return [Direction.RIGHT, Direction.DOWN, Direction.LEFT];\n        case RoadTileType.UP_DOWN_LEFT:\n            return [Direction.UP, Direction.DOWN, Direction.LEFT];\n        case RoadTileType.UP_RIGHT_LEFT:\n            return [Direction.UP, Direction.RIGHT, Direction.LEFT];\n        case RoadTileType.UP_RIGHT_DOWN_LEFT:\n            return [Direction.UP, Direction.RIGHT, Direction.DOWN, Direction.LEFT];\n        default:\n            throw Error('Invalid road tile type');\n    }\n}\n\nexport function roadTileTypeIsIntersection(roadTileType) {\n    return getSegmentDirectionsForRoadTileType(roadTileType).length >= 3;\n}\n\nexport function RoadTile(props) {\n    return (\n        <div>\n            <p className='road-tile-descriptor'>{props.displayRoadTileDescriptor ? props.type : ''}</p>\n            <div className={`road-tile road-tile${props.type}`}></div>\n        </div >\n    );\n}\n\nRoadTile.propTypes = {\n    displayRoadTileDescriptor: PropTypes.bool.isRequired,\n    type: PropTypes.number.isRequired,\n}","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport './Grid.css';\nimport { RoadTile, RoadTileType } from '../RoadTile/RoadTile';\nimport { Direction } from '../../util/Direction';\n\nexport class RoadTileMatrix {\n    constructor(rows, cols, innerArray) {\n        // If no array provided, populate it.\n        if (!innerArray) {\n            innerArray = new Array(rows);\n            for (let r = 0; r < rows; r++) {\n                innerArray[r] = new Array(cols);\n            }\n            for (let r = 0; r < rows; r++) {\n                for (let c = 0; c < cols; c++) {\n                    innerArray[r][c] = RoadTileType.EMPTY;\n                }\n            }\n        }\n\n        this.rows = rows;\n        this.cols = cols;\n        this.innerArray = innerArray;\n    }\n\n    get(r, c) {\n        return this.innerArray[r][c];\n    }\n\n    getNeighbors(r, c) {\n        const neighbors = {};\n        if (r - 1 >= 0 && this.innerArray[r - 1][c] !== RoadTileType.EMPTY) {\n            neighbors[Direction.UP] = {\n                coords: [r - 1, c],\n                type: this.innerArray[r - 1][c],\n            }\n        }\n        if (c + 1 < this.cols && this.innerArray[r][c + 1] !== RoadTileType.EMPTY) {\n            neighbors[Direction.RIGHT] = {\n                coords: [r, c + 1],\n                type: this.innerArray[r][c + 1],\n            }\n        }\n        if (r + 1 < this.rows && this.innerArray[r + 1][c] !== RoadTileType.EMPTY) {\n            neighbors[Direction.DOWN] = {\n                coords: [r + 1, c],\n                type: this.innerArray[r + 1][c],\n            }\n        }\n        if (c - 1 >= 0 && this.innerArray[r][c - 1] !== RoadTileType.EMPTY) {\n            neighbors[Direction.LEFT] = {\n                coords: [r, c - 1],\n                type: this.innerArray[r][c - 1],\n            }\n        }\n        return neighbors;\n    }\n\n    hasNeighbors(r, c) {\n        return Object.keys(this.getNeighbors(r, c)).length > 0;\n    }\n\n    evaluateRoadTileType(r, c, wasAdded) {\n        /* wasAdded: whether the road tile was newly added to the grid, i.e.\n                     changed from RoadTileType.EMPTY */\n\n        // Optimization: don't update empty spaces unless we recently added a\n        // tile there.\n        if (!wasAdded && this.innerArray[r][c] === RoadTileType.EMPTY) {\n            return RoadTileType.EMPTY;\n        }\n\n        const neighbors = this.getNeighbors(r, c)\n        const numNeighbors = Object.keys(neighbors).length;\n        const up = typeof neighbors[Direction.UP] !== 'undefined';\n        const right = typeof neighbors[Direction.RIGHT] !== 'undefined';\n        const down = typeof neighbors[Direction.DOWN] !== 'undefined';\n        const left = typeof neighbors[Direction.LEFT] !== 'undefined';\n\n        if (numNeighbors === 0) {\n            return RoadTileType.ALONE;\n        } else if (numNeighbors === 1) {\n            if (up) {\n                return RoadTileType.UP;\n            } else if (right) {\n                return RoadTileType.RIGHT;\n            } else if (down) {\n                return RoadTileType.DOWN;\n            } else if (left) {\n                return RoadTileType.LEFT;\n            }\n        } else if (numNeighbors === 2) {\n            if (up && right) {\n                return RoadTileType.UP_RIGHT;\n            } else if (right && down) {\n                return RoadTileType.RIGHT_DOWN;\n            } else if (down && left) {\n                return RoadTileType.DOWN_LEFT;\n            } else if (up && left) {\n                return RoadTileType.UP_LEFT;\n            } else if (up && down) {\n                return RoadTileType.UP_DOWN;\n            } else if (right && left) {\n                return RoadTileType.RIGHT_LEFT;\n            }\n        } else if (numNeighbors === 3) {\n            if (up && right && down) {\n                return RoadTileType.UP_RIGHT_DOWN;\n            } else if (right && down && left) {\n                return RoadTileType.RIGHT_DOWN_LEFT;\n            } else if (up && down && left) {\n                return RoadTileType.UP_DOWN_LEFT;\n            } else if (up && right && left) {\n                return RoadTileType.UP_RIGHT_LEFT;\n            }\n        } else if (numNeighbors === 4) {\n            return RoadTileType.UP_RIGHT_DOWN_LEFT;\n        }\n    }\n\n    /**\n     * Update tile type.\n     * @param {number} row\n     * @param {number} col\n     * @param {boolean} wasAdded Whether the RoadTile was newly added to the\n     *                  grid, i.e. changed from RoadTileType.EMPTY.\n     */\n    updateTile(r, c, wasAdded) {\n        this.innerArray[r][c] = this.evaluateRoadTileType(r, c, wasAdded)\n    }\n\n    _updateNeighbors(r, c, wasAdded) {\n        if (r - 1 >= 0) {\n            this.updateTile(r - 1, c, wasAdded);\n        }\n        if (c + 1 < this.cols) {\n            this.updateTile(r, c + 1, wasAdded);\n        }\n        if (r + 1 < this.rows) {\n            this.updateTile(r + 1, c, wasAdded);\n        }\n        if (c - 1 >= 0) {\n            this.updateTile(r, c - 1, wasAdded);\n        }\n    }\n\n    /**\n     * Add tile.\n     * @param {number} row\n     * @param {number} col\n     * @param {boolean} restrictToNeighbors Tile must be placed next to another\n     *                  tile.\n     * @returns {boolean} Tile was added.\n     */\n    addTile(r, c, restrictToNeighbors) {\n        if (this.innerArray[r][c] !== RoadTileType.EMPTY) {\n            return false;\n        }\n        if (restrictToNeighbors && !this.hasNeighbors(r, c)) {\n            return false;\n        }\n        this.updateTile(r, c, true);\n        this._updateNeighbors(r, c, false);\n        return true;\n    }\n\n    tileCanBeRemoved(r, c) {\n        return this.innerArray[r][c] !== RoadTileType.EMPTY;\n    }\n\n    /**\n     * Remove tile.\n     * @param {number} row\n     * @param {number} col\n     */\n    removeTile(r, c) {\n        this.innerArray[r][c] = RoadTileType.EMPTY;\n        this._updateNeighbors(r, c, false);\n    }\n}\n\nexport class Grid extends React.Component {\n    mouseDownHandler(e, r, c) {\n        e.preventDefault();\n        switch (e.buttons) {\n            case 1:\n                this.props.addRoad(r, c, false);\n                break;\n            case 2:\n                this.props.removeRoad(r, c);\n                break;\n            default:\n                break;\n        }\n    }\n\n    mouseOverHandler({ buttons }, r, c) {\n        switch (buttons) {\n            case 1:\n                this.props.addRoad(r, c, false);\n                break;\n            case 2:\n                this.props.removeRoad(r, c);\n                break;\n            default:\n                break;\n        }\n    }\n\n    render() {\n        const globalSettings = this.props.globalSettings;\n        const roadTileMatrix = this.props.roadTileMatrix;\n        const rows = roadTileMatrix.rows;\n        const cols = roadTileMatrix.cols;\n\n        const roadTileDivs = []\n\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < cols; c++) {\n                roadTileDivs.push((\n                    <div\n                        key={`grid-tile${r * cols + c}`}\n                        className='grid-tile'\n                        onMouseDown={(e) => this.mouseDownHandler(e, r, c)}\n                        onMouseOver={(e) => this.mouseOverHandler(e, r, c)}\n                        onContextMenu={\n                            /* disable right click context menu */\n                            (e) => e.preventDefault()\n                        }>\n                        <RoadTile\n                            displayRoadTileDescriptor={globalSettings.displayRoadTileDescriptors}\n                            type={roadTileMatrix.get(r, c)} />\n                    </div >\n                ));\n            }\n        }\n        return (\n            <div className=\"grid-wrapper\">\n                {roadTileDivs}\n            </div>\n        );\n    }\n}\n\nGrid.propTypes = {\n    globalSettings: PropTypes.object.isRequired,\n    roadTileMatrix: PropTypes.object.isRequired,\n    addRoad: PropTypes.func.isRequired,\n    removeRoad: PropTypes.func.isRequired,\n}","import { Direction } from '../../util/Direction';\n\nconst CLEAR_TIME_DURATION = 1000; // ms\nconst WAIT_TIME_DURATION = 1000; // ms\n\n/**\n * An Intersection construct that determines how Vehicles pass between\n * intersection TravelNodes in the TravelGraph.\n *\n * Behaves as if all segment directions have a stop sign.\n */\nexport class Intersection {\n    /**\n     * Constructor\n     */\n    constructor() {\n        this.vehicles = {}\n        this.vehicles[Direction.UP] = null;\n        this.vehicles[Direction.RIGHT] = null;\n        this.vehicles[Direction.DOWN] = null;\n        this.vehicles[Direction.LEFT] = null;\n\n        this.waitTimersMillisec = {}\n        this.waitTimersMillisec[Direction.UP] = 0;\n        this.waitTimersMillisec[Direction.RIGHT] = 0;\n        this.waitTimersMillisec[Direction.DOWN] = 0;\n        this.waitTimersMillisec[Direction.LEFT] = 0;\n\n        // Array for tracking which direction to dequeue next.\n        this._dequeueOrder = [\n            Direction.UP,\n            Direction.RIGHT,\n            Direction.DOWN,\n            Direction.LEFT,\n        ]\n\n        // Timer to give vehicle in the middle of the intersection time to\n        // leave the intersection before dequeuing the next vehicle in the\n        // intersection.\n        this._clearTimer = 0\n    }\n\n    static get CLEAR_TIME_DURATION() {\n        return CLEAR_TIME_DURATION;\n    }\n\n    static get WAIT_TIME_DURATION() {\n        return WAIT_TIME_DURATION;\n    }\n\n    /**\n     * Add Vehicle to direction queue.\n     * @param {Vehicle} vehicle\n     * @param {Direction} direction\n     */\n    enqueue(vehicle, direction) {\n        this.waitTimersMillisec[direction] = Intersection.WAIT_TIME_DURATION;\n        this.vehicles[direction] = vehicle;\n    }\n\n    /**\n     * Remove Vehicle from Direction queue.\n     * @param {Direction} direction\n     */\n    _dequeue(direction) {\n        const dequeuedVehicle = this.vehicles[direction];\n        this.vehicles[direction] = null;\n        return dequeuedVehicle;\n    }\n\n    /**\n     * Release Vehicles from the queue, when possible.\n     * @param {number} tickMillisec\n     * @returns {Vehicle} if one dequeued, else null\n     */\n    step(tickMillisec) {\n        for (let direction in this.waitTimersMillisec) {\n            const timer = this.waitTimersMillisec[direction];\n            this.waitTimersMillisec[direction] = Math.max(timer - tickMillisec, 0)\n        }\n\n        this._clearTimer = Math.max(this._clearTimer - tickMillisec, 0);\n        if (this._clearTimer > 0) {\n            return null;\n        }\n\n        // Vehicles should enter the intersection in a clockwise rotation.\n        // Determine order of directions to let out by rotating our list.\n        //     Example: RIGHT let out last, dequeue DOWN\n        //       [DOWN, LEFT, UP, RIGHT] -> [LEFT, UP, RIGHT, DOWN]\n        //     Example: UP let out last, dequeue RIGHT\n        //       [RIGHT, DOWN, LEFT, UP] -> [DOWN, LEFT, UP, RIGHT]\n        for (let i = 0; i < this._dequeueOrder.length; i++) {\n            // Rotate order\n            let direction = this._dequeueOrder.shift();\n            this._dequeueOrder.push(direction);\n\n            if (this.waitTimersMillisec[direction] > 0) {\n                continue;\n            }\n\n            if (this.vehicles[direction]) {\n                this._clearTimer = Intersection.CLEAR_TIME_DURATION;\n                return this._dequeue(direction);\n            }\n        }\n        return null;\n    }\n}","import PropTypes from 'prop-types';\n\nimport React from 'react';\n\nexport class Rectangle {\n    constructor(centerX, centerY, w, h, angleRad, xOffset, yOffset) {\n        this.centerX = centerX;\n        this.centerY = centerY;\n        this.w = w;\n        this.h = h;\n        this.angleRad = angleRad;\n        this.xOffset = xOffset;\n        this.yOffset = yOffset;\n\n        this.defaultVertices = [\n            { x: this.centerX - this.w / 2 + xOffset, y: this.centerY - this.h / 2 + yOffset },\n            { x: this.centerX + this.w / 2 + xOffset, y: this.centerY - this.h / 2 + yOffset },\n            { x: this.centerX + this.w / 2 + xOffset, y: this.centerY + this.h / 2 + yOffset },\n            { x: this.centerX - this.w / 2 + xOffset, y: this.centerY + this.h / 2 + yOffset },\n        ]\n\n        this.vertices = [\n            { x: this.centerX - this.w / 2 + xOffset, y: this.centerY - this.h / 2 + yOffset },\n            { x: this.centerX + this.w / 2 + xOffset, y: this.centerY - this.h / 2 + yOffset },\n            { x: this.centerX + this.w / 2 + xOffset, y: this.centerY + this.h / 2 + yOffset },\n            { x: this.centerX - this.w / 2 + xOffset, y: this.centerY + this.h / 2 + yOffset },\n        ]\n\n        this.rotateToAngleRad(this.angleRad);\n    }\n\n    get minX() {\n        return Math.min(...this.vertices.map(v => v.x));\n    }\n\n    get maxX() {\n        return Math.max(...this.vertices.map(v => v.x));\n    }\n\n    get minY() {\n        return Math.min(...this.vertices.map(v => v.y));\n    }\n\n    get maxY() {\n        return Math.max(...this.vertices.map(v => v.y));\n    }\n\n    get boundingWidth() {\n        return this.maxX - this.minX;\n    }\n\n    get boundingHeight() {\n        return this.maxY - this.minY;\n    }\n\n    get topLeft() {\n        return { top: this.minY, left: this.minX };\n    }\n\n    get verticesAtOrigin() {\n        return this.vertices.map(e => [e.x - this.minX, e.y - this.minY]);\n    }\n\n    get center() {\n        return { x: this.centerX, y: this.centerY };\n    }\n\n    _rotatePointAroundCenter(p, c, angleRad) {\n        const x1 = p.x - c.x;\n        const y1 = p.y - c.y;\n\n        const x2 = x1 * Math.cos(angleRad) - y1 * Math.sin(angleRad);\n        const y2 = x1 * Math.sin(angleRad) + y1 * Math.cos(angleRad);\n\n        return { x: x2 + c.x, y: y2 + c.y };\n    }\n\n    translate(x0, y0) {\n        this.centerX += x0;\n        this.centerY += y0;\n        this.vertices = this.vertices.map(v => { return { x: v.x + x0, y: v.y + y0 } });\n        this.defaultVertices = this.defaultVertices.map(v => { return { x: v.x + x0, y: v.y + y0 } });\n    }\n\n    rotateToAngleRad(angleRad) {\n        const center = this.center;\n        this.vertices = [\n            this._rotatePointAroundCenter(this.defaultVertices[0], center, angleRad),\n            this._rotatePointAroundCenter(this.defaultVertices[1], center, angleRad),\n            this._rotatePointAroundCenter(this.defaultVertices[2], center, angleRad),\n            this._rotatePointAroundCenter(this.defaultVertices[3], center, angleRad),\n        ];\n        this.angleRad = angleRad;\n    }\n\n    rotateDeg(angleDeg) {\n        this.angleRad = (this.angleRad + angleDeg * (Math.PI / 180)) % (2 * Math.PI);\n        this.rotateToAngleRad(this.angleRad);\n    }\n}\n\nexport class RectangleCollider extends Rectangle {\n    _hasSeparatingAxis(a, b) {\n        // test each side of a in turn:\n        const sides = 4;\n        for (let i = 0; i < sides; i++) {\n            let normal_x = a.vertices[(i + 1) % sides].y - a.vertices[i].y;\n            let normal_y = a.vertices[i].x - a.vertices[(i + 1) % sides].x;\n            for (let j = 0; j < sides; j++) {\n                let dot_product = ((b.vertices[j].x - a.vertices[i].x) * normal_x) +\n                    ((b.vertices[j].y - a.vertices[i].y) * normal_y);\n                if (dot_product <= 0.0)\n                    break;\n                if (j === sides - 1)\n                    return true; // all dots were +ve, we found a separating axis\n            }\n        }\n        return false;\n    }\n\n    collidesWith(rect) {\n        return !this._hasSeparatingAxis(this, rect) && !this._hasSeparatingAxis(rect, this);\n    }\n}\n\nexport class RectangleComponent extends React.Component {\n    get polygonStr() {\n        const rect = this.props.rect;\n        // Create str of vertices, e.g. '1px 2px, 3px 4px, ...'\n        const verticesStr = rect.verticesAtOrigin.map(e => e.map(f => f + 'px').join(' ')).join(', ');\n        return `polygon(${verticesStr})`;\n    }\n\n    render() {\n        const rect = this.props.rect;\n        return (\n            <div style={{\n                position: 'absolute',\n                backgroundColor: this.props.backgroundColor,\n                width: rect.boundingWidth + 'px',\n                height: rect.boundingHeight + 'px',\n                top: rect.topLeft.top,\n                left: rect.topLeft.left,\n                clipPath: this.polygonStr,\n            }}>\n            </div >\n        );\n    }\n}\n\nRectangleComponent.propTypes = {\n    rect: PropTypes.object.isRequired,\n    backgroundColor: PropTypes.string.isRequired,\n}","/**\n * Directed, disconnected graph with positive integers as node identifiers.\n */\nclass Graph {\n    constructor() {\n        this.edges = {};  // source: [targets]\n    }\n\n    get nodes() {\n        return Object.keys(this.edges).map(e => Number(e));\n    }\n\n    /**\n     * Check if value is a positive integer.\n     * @param {*} val\n     * @param {string} name Name of value\n     * @throws TypeError\n     */\n    _checkIsPositiveInteger(val, name) {\n        if (!Number.isInteger(val) || val < 0) {\n            throw new TypeError(`${name} must be a positive integer.`);\n        }\n    }\n\n    /**\n     * Add edge to graph, adding nodes if not already exists.\n     * @param {number} source\n     * @param {number} target\n     */\n    addEdge(source, target) {\n        this._checkIsPositiveInteger(source, 'source');\n        this._checkIsPositiveInteger(target, 'target');\n\n        // Add nodes, if not already exist\n        if (!this.edges.hasOwnProperty(source)) {\n            this.edges[source] = [];\n        }\n        if (!this.edges.hasOwnProperty(target)) {\n            this.edges[target] = [];\n        }\n\n        // Add edge, if not already exists\n        if (!this.edges[source].includes(target)) {\n            this.edges[source].push(target);\n        }\n    }\n\n    /**\n     * Remove edge from graph, removing orphaned nodes if any created.\n     * @param {number} source\n     * @param {number} target\n     */\n    removeEdge(source, target) {\n        this._checkIsPositiveInteger(source, 'source');\n        this._checkIsPositiveInteger(target, 'target');\n\n        if (!this.edges.hasOwnProperty(source)) {\n            return;\n        }\n\n        this.edges[source] = this.edges[source].filter(\n            n => n !== target\n        );\n\n        // Remove orphaned nodes\n        if (this.inDegree(source) === 0 && this.outDegree(source) === 0) {\n            delete this.edges[source];\n        }\n        if (this.inDegree(target) === 0 && this.outDegree(target) === 0) {\n            delete this.edges[target];\n        }\n    }\n\n    /**\n     * Remove node grom graph, removing all edges into and out of the node and\n     * removing any orphaned nodes if any are created.\n     * @param {number} source\n     */\n    removeNode(source) {\n        this._checkIsPositiveInteger(source, 'source');\n\n        if (!this.edges.hasOwnProperty(source)) {\n            return;\n        }\n\n        // Remove node\n        delete this.edges[source];\n\n        // Remove references to node\n        for (let key in this.edges) {\n            key = Number(key);\n\n            // Remove indegree edges to node\n            const indexOf = this.edges[key].indexOf(source);\n            if (indexOf > -1) {\n                this.edges[key].splice(indexOf, 1);\n            }\n\n            // If node is now orphaned, remove\n            if (this.inDegree(key) === 0 && this.outDegree(key) === 0) {\n                delete this.edges[key]\n            }\n        }\n    }\n\n    /**\n     * Computes number of incoming edges for specified node.\n     * @param {number} source\n     * @returns {number} inDegree\n     */\n    inDegree(source) {\n        this._checkIsPositiveInteger(source, 'source');\n        let inDegree = 0;\n        Object.values(this.edges).forEach(e => {\n            if (e.includes(source)) {\n                inDegree++;\n            }\n        });\n        return inDegree;\n    }\n\n    /**\n     * Computes number of outgoing edges for specified node.\n     * @param {number} source\n     * @returns {number} outDegree\n     */\n    outDegree(source) {\n        this._checkIsPositiveInteger(source, 'source');\n        return this.edges[source].length;\n    }\n\n    /**\n     * Get nodes adjacent to source, i.e for edges source->v, returns all v.\n     * @param {number} source\n     * @returns {Array<number>} Adjacent nodes\n     */\n    adjacent(source) {\n        this._checkIsPositiveInteger(source, 'source');\n        return this.edges[source];\n    }\n\n    /**\n     * Get nodes along path from source. Does not include source.\n     * @param {number} source\n     * @returns {Set<number>} Nodes along path starting from source.\n     */\n    alongPath(source) {\n        this._checkIsPositiveInteger(source, 'source');\n\n        const nodesAlongPath = new Set();\n        const visited = new Set();\n        const stack = [...this.adjacent(source)];\n\n        visited.add(source);\n\n        // DFS\n        while (stack.length > 0) {\n            const curNode = stack.pop();\n            if (visited.has(curNode)) {\n                continue;\n            }\n            stack.push(...this.adjacent(curNode));\n            nodesAlongPath.add(curNode);\n            visited.add(curNode);\n        }\n\n        return nodesAlongPath;\n    }\n\n    /**\n     * Use Djikstra's algorithm to find shortest path from source -> target.\n     * Includes source node in path.\n     * @param {number} source\n     * @param {number} target\n     * @throws Error if no path found\n     */\n    shortestPath(source, target) {\n        this._checkIsPositiveInteger(source, 'source');\n        this._checkIsPositiveInteger(target, 'target');\n\n        const dist = {};\n        const previous = {};\n        let remaining = this.nodes;\n\n        // Initialize distances\n        remaining.forEach(e => {\n            dist[e] = Infinity;\n            previous[e] = null;\n        });\n        dist[source] = 0;\n\n        // Calculate distances between nodes\n        while (remaining.length > 0) {\n            // Find node, u, with shortest distance\n            let shortestDist = Infinity;\n            let u = remaining[0];\n            for (let idx = 0; idx < remaining.length; idx++) {\n                const node = remaining[idx];\n                if (dist[node] < shortestDist) {\n                    u = node;\n                    shortestDist = dist[node];\n                }\n            }\n\n            // Update distances\n            const adjacent = this.adjacent(u)\n            adjacent.forEach(v => {\n                const alt = dist[u] + 1;\n                if (alt < dist[v]) {\n                    dist[v] = alt;\n                    previous[v] = u;\n                }\n            });\n\n            // Remove u from remaining\n            remaining = remaining.filter(e => e !== u);\n        }\n\n        // No path to target\n        if (dist[target] === Infinity) {\n            throw new Error(`No path from ${source} to ${target}.`);\n        }\n\n        // Build path\n        const path = [];\n        let curNode = target;\n        while (curNode !== null) {\n            path.unshift(curNode);\n            curNode = previous[curNode];\n        }\n        return path;\n    }\n\n    /**\n     * Serialize edges into array of objects.\n     * @returns {Array<Object>} Serialized edges\n     */\n    serializeEdges() {\n        const serializedEdges = []\n        for (const key in this.edges) {\n            const source = Number(key);\n            serializedEdges.push(...this.edges[source].map(\n                target => {\n                    return {\n                        source: source,\n                        target: target,\n                    }\n                }\n            ));\n        }\n        return serializedEdges;\n    }\n}\n\nexport default Graph;","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Line } from 'react-lineto';\n\nimport './TravelGraph.css';\nimport { getSegmentDirectionsForRoadTileType } from '../RoadTile/RoadTile';\nimport { Direction, oppositeDirection } from '../../util/Direction';\nimport Graph from '../../util/Graph';\n\nexport const TravelNodeType = {\n    ENTER: 0,\n    EXIT: 1,\n};\nObject.freeze(TravelNodeType);\n\nexport class TravelNode {\n    static count = 0;\n\n    constructor(row, col, direction, travelNodeType) {\n        this.id = TravelNode.count++;\n\n        this.row = row;\n        this.col = col;\n        this.direction = direction;\n        this.travelNodeType = travelNodeType;\n\n        // Calculate (x, y)\n\n        // Pull variables from .css\n        const style = getComputedStyle(document.documentElement);\n        const tileWidth = style.getPropertyValue('--tile-width-raw');\n        const tileHeight = style.getPropertyValue('--tile-height-raw');\n\n        // Find middle location of tile\n        const topX = col * tileWidth;\n        const topY = row * tileHeight;\n        const middleX = topX + .50 * tileWidth;\n        const middleY = topY + .50 * tileHeight;\n\n        // Set node (x, y) to middle of tile\n        this.x = middleX;\n        this.y = middleY;\n\n        // Shift node (x, y) based on properties\n        if (this.direction === Direction.UP) {\n            this.y -= tileHeight / 3;\n            if (this.travelNodeType === TravelNodeType.ENTER) {\n                this.x -= tileWidth / 8;\n            } else if (this.travelNodeType === TravelNodeType.EXIT) {\n                this.x += tileWidth / 8;\n            }\n        } else if (this.direction === Direction.RIGHT) {\n            this.x += tileWidth / 3;\n            if (this.travelNodeType === TravelNodeType.ENTER) {\n                this.y -= tileHeight / 8;\n            } else if (this.travelNodeType === TravelNodeType.EXIT) {\n                this.y += tileHeight / 8;\n            }\n        } else if (this.direction === Direction.DOWN) {\n            this.y += tileHeight / 3;\n            if (this.travelNodeType === TravelNodeType.ENTER) {\n                this.x += tileWidth / 8;\n            } else if (this.travelNodeType === TravelNodeType.EXIT) {\n                this.x -= tileWidth / 8;\n            }\n        } else if (this.direction === Direction.LEFT) {\n            this.x -= tileWidth / 3;\n            if (this.travelNodeType === TravelNodeType.ENTER) {\n                this.y += tileHeight / 8;\n            } else if (this.travelNodeType === TravelNodeType.EXIT) {\n                this.y -= tileHeight / 8;\n            }\n        }\n    }\n}\n\n/**\n * An intersection on the TileGrid comprised of nodes on the TravelGraph\n * that represents all ENTER and EXIT travel nodes for the given tile.\n *\n * Each road segment on a tile (i.e. UP, RIGHT, DOWN, LEFT) has an ENTER and\n * EXIT node denoting where traffic flows into and out of the tile,\n * respectively.\n *\n * Structure:\n *     self.nodes = {\n *         Direction: {\n *             TravelNodeType.ENTER: TravelNode,\n *             TravelNodeType.EXIT: TravelNode,\n *         },\n *         ..\n *     }\n */\nexport class TravelIntersection {\n    constructor(row, col, tileType) {\n        this.row = row;\n        this.col = col;\n        this.nodes = {};\n\n        getSegmentDirectionsForRoadTileType(tileType).forEach(\n            direction => { this.addTravelNodes(direction) }\n        );\n    }\n\n    addTravelNodes(direction) {\n        this.nodes[direction] = {}\n        this.nodes[direction][TravelNodeType.EXIT] =\n            new TravelNode(this.row, this.col, direction, TravelNodeType.EXIT);\n        this.nodes[direction][TravelNodeType.ENTER] =\n            new TravelNode(this.row, this.col, direction, TravelNodeType.ENTER);\n    }\n\n    removeTravelNodes(direction) {\n        delete this.nodes[direction];\n    }\n\n    getSegmentDirections() {\n        return Object.keys(this.nodes);\n    }\n\n    getEnterNodes() {\n        const enterNodes = [];\n        this.getSegmentDirections().forEach(direction => {\n            enterNodes.push(this.nodes[direction][TravelNodeType.ENTER]);\n        });\n        return enterNodes;\n    }\n\n    getExitNodes() {\n        const exitNodes = [];\n        this.getSegmentDirections().forEach(direction => {\n            exitNodes.push(this.nodes[direction][TravelNodeType.EXIT]);\n        });\n        return exitNodes;\n    }\n\n    getNodesForSegment(direction) {\n        return [\n            this.nodes[direction][TravelNodeType.EXIT],\n            this.nodes[direction][TravelNodeType.ENTER],\n        ];\n    }\n}\n\nexport class TravelGraph {\n    constructor(graph, nodes, intersections) {\n        this.graph = graph || new Graph();\n        this.nodes = nodes || {};\n        this.intersections = intersections || {};\n    }\n\n    hasNode(id) {\n        return Object.keys(this.nodes).includes(String(id));\n    }\n\n    getNode(id) {\n        return this.nodes[id];\n    }\n\n    getNodes() {\n        return this.nodes;\n    }\n\n    getNewestNode() {\n        if (Object.keys(this.nodes).length === 0) {\n            return null;\n        }\n        const newestKey = Object.keys(this.nodes).reduce(\n            (a, b) => Number(a) > Number(b) ? a : b\n        );\n        return this.nodes[newestKey];\n    }\n\n    getRandomNodeAlongPath(startNodeId) {\n        const possibleNodeIds = Array.from(this.graph.alongPath(startNodeId));\n        const randIdx = Math.floor(Math.random() * possibleNodeIds.length);\n        const nodeId = possibleNodeIds[randIdx];\n        return this.nodes[nodeId];\n    }\n\n    getEdges() {\n        return this.graph.serializeEdges();\n    }\n\n    getShortestPath(startNodeId, endNodeId) {\n        return this.graph.shortestPath(startNodeId, endNodeId);\n    }\n\n    registerTravelIntersection(r, c, roadTileType, neighbors) {\n        const insct = new TravelIntersection(r, c, roadTileType);\n        this._intraconnectRoads(insct);\n\n        // Neighbor intersections will have a new segment added to their tile to\n        // bridge the connection to the newly placed tile. Add ENTER and EXIT\n        // nodes to all neighbor's new segments and recompute their\n        // intraconnected edges to account for this update.\n        for (const nDirection in neighbors) {\n            const neighbor = neighbors[nDirection];\n            const nR = neighbor.coords[0];\n            const nC = neighbor.coords[1];\n\n            const nInsct = this.intersections[[nR, nC]];\n            nInsct.addTravelNodes(oppositeDirection(nDirection));\n            this._removeIntersectionIntraconnectedEdges(nInsct);\n        }\n\n        // Add edges between intersection and neighbor intersections\n        for (const nDirection in neighbors) {\n            const neighbor = neighbors[nDirection];\n            const nR = neighbor.coords[0];\n            const nC = neighbor.coords[1];\n\n            const nInsct = this.intersections[[nR, nC]];\n\n            const [exit, enter] = insct.getNodesForSegment(nDirection);\n            const [nExit, nEnter] = nInsct.getNodesForSegment(oppositeDirection(nDirection));\n\n            this._addEdge(exit, nEnter);\n            this._addEdge(nExit, enter);\n        }\n\n        this.intersections[[r, c]] = insct;\n    }\n\n    unregisterTravelIntersection(r, c, neighbors) {\n        const insct = this.intersections[[r, c]];\n\n        for (const nDirection in neighbors) {\n            const [exit, enter] = insct.getNodesForSegment(nDirection);\n\n            const neighbor = neighbors[nDirection];\n            const [nR, nC] = neighbor.coords;\n            const nInsct = this.intersections[[nR, nC]];\n            const [nExit, nEnter] = nInsct.getNodesForSegment(oppositeDirection(nDirection));\n            this._removeNode(exit);\n            this._removeNode(enter);\n\n            nInsct.removeTravelNodes(oppositeDirection(nDirection));\n            this._removeNode(nExit);\n            this._removeNode(nEnter);\n\n            this._intraconnectRoads(nInsct);\n        }\n\n        delete this.intersections[[r, c]];\n    }\n\n    _addEdge(exit, enter) {\n        this.graph.addEdge(exit.id, enter.id);\n\n        // Create way to reference these nodes later\n        this.nodes[exit.id] = exit;\n        this.nodes[enter.id] = enter;\n    }\n\n    _removeEdge(exit, enter) {\n        this.graph.removeEdge(exit.id, enter.id);\n        // TODO for proper removal, remove nodes from this.nodes if\n        // indegree and outdegree length === 0\n    }\n\n    _removeNode(node) {\n        this.graph.removeNode(node.id);\n    }\n\n    _intraconnectRoads(insct) {\n        const segmentDirections = insct.getSegmentDirections();\n\n        if (segmentDirections.length === 1) {\n            // Only one segment. Connect the two nodes, so vehicles can make a\n            // U-Turn at dead-ends.\n            const [exit, enter] = insct.getNodesForSegment(segmentDirections[0]);\n            this._addEdge(enter, exit);\n\n        } else {\n            // Connect segments' ENTER nodes to other segments' EXIT nodes\n            // This is overkill when we're updating an intersection since most edges\n            // already exist, but since this likely only happens on a player action\n            // and not in the game loop we're ok with the efficiency hit.\n            insct.getEnterNodes().forEach(enter => {\n                insct.getExitNodes().forEach(exit => {\n                    if (exit.direction !== enter.direction) {\n                        this._addEdge(enter, exit);\n                    }\n                })\n            });\n        }\n    }\n\n    /**\n     * Update existing intersection's edges to match desired configuration\n     * for current set of nodes.\n     *\n     * Should only be used on existing intersections in the graph that have\n     * been updated via a road adjacent to it, i.e. do not run this for newly\n     * placed dead-end tiles.\n     * @param {TravelIntersection} insct\n     */\n    _removeIntersectionIntraconnectedEdges(insct) {\n        // Clear all self-connected edges from existing dead-end segments\n        // We don't know which one was newly added, so go through each segment\n        // and try removing any self-connections\n        insct.getSegmentDirections().forEach(direction => {\n            const [exit, enter] = insct.getNodesForSegment(direction);\n            this._removeEdge(enter, exit);\n        });\n\n        this._intraconnectRoads(insct);\n    }\n}\n\nexport class TravelEdge extends React.Component {\n    render() {\n        const exitNode = this.props.exitNode;\n        const enterNode = this.props.enterNode;\n        return (\n            <div>\n                <p\n                    className=\"node-label\"\n                    style={{\n                        top: `${exitNode.y}px`,\n                        left: `${exitNode.x}px`,\n                    }}\n                >\n                    {exitNode.id}\n                </p>\n                <Line\n                    x0={exitNode.x}\n                    y0={exitNode.y}\n                    x1={enterNode.x}\n                    y1={enterNode.y} />\n            </div >\n        );\n    }\n}\n\nTravelEdge.propTypes = {\n    exitNode: PropTypes.object.isRequired,\n    enterNode: PropTypes.object.isRequired,\n};\n\nexport class TravelGraphComponent extends React.Component {\n    render() {\n        const travelGraph = this.props.travelGraph;\n        const globalSettings = this.props.globalSettings;\n        if (globalSettings.displayTravelEdges) {\n            // TODO This is bad. Relies too much on the inner workings of the graph\n            return (\n                <div>\n                    {travelGraph.getEdges().map(edge => {\n                        const exitNode = travelGraph.getNode(edge.source);\n                        const enterNode = travelGraph.getNode(edge.target);\n                        return (\n                            <TravelEdge\n                                key={`travel-edge-${exitNode.id}-${enterNode.id}`}\n                                exitNode={exitNode} enterNode={enterNode} />\n                        );\n                    })}\n                </div>\n            );\n        } else {\n            return <div></div>;\n        }\n    }\n}\n\nTravelGraphComponent.propTypes = {\n    globalSettings: PropTypes.object.isRequired,\n    travelGraph: PropTypes.object.isRequired,\n};","import PropTypes from 'prop-types';\n\nimport './Vehicle.css';\nimport { Rectangle, RectangleCollider, RectangleComponent } from '../../util/collision/Rectangle';\nimport { roadTileTypeIsIntersection } from '../RoadTile/RoadTile';\nimport { TravelNodeType } from '../TravelGraph/TravelGraph';\nimport { getRandomInt } from '../../util/Random';\n\nexport class Vehicle extends Rectangle {\n    constructor(id, x, y, startNodeId) {\n        super(x, y, 8, 4, 0, 0, 0);\n\n        this.id = id;\n        this.color = this.randomColor();\n        this.path = [];\n        this.prevTargetId = startNodeId;\n        this.speedPerSec = 30;\n\n        const xOffset = 6;\n        const yOffset = 0;\n        this.frontCollider = new RectangleCollider(x, y, 4, 2, this.angleRad, xOffset, yOffset);\n\n        // Can be modified externally\n        this.waitingAtInsct = false;\n    }\n\n    randomColor() {\n        const h = getRandomInt(0, 359);\n        return `hsl(${h}, 100%, 75%)`;\n    }\n\n    setPath(path) {\n        this.path = path;\n    }\n\n    setRandomPath(travelGraph) {\n        const randPath = this._getRandomPath(travelGraph, this.prevTargetId);\n        this.setPath(randPath);\n    }\n\n    resetRandomPath(travelGraph) {\n        if (travelGraph.hasNode(this.path[0])) {\n            // Continue routing to current target, then set new objective\n            const randPath = this._getRandomPath(travelGraph, this.path[0]);\n            this.setPath(randPath);\n        } else {\n            // Current target no longer exists, reroute based on prev target\n            const randPath = this._getRandomPath(travelGraph, this.prevTargetId);\n            this.prevTargetId = randPath.shift();\n            this.setPath(randPath);\n        }\n    }\n\n    _getRandomPath(travelGraph, startNodeId) {\n        const randTarget = travelGraph.getRandomNodeAlongPath(startNodeId);\n        return travelGraph.getShortestPath(startNodeId, randTarget.id);\n    }\n\n    _moveTowardsTarget(remainingSpeed, targetNode) {\n        const x1 = this.centerX;\n        const y1 = this.centerY;\n        const x2 = targetNode.x;\n        const y2 = targetNode.y;\n        const dx = x2 - x1;\n        const dy = y2 - y1;;\n\n        const distToNode = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n\n        const speedPerSec = Math.min(remainingSpeed, distToNode);\n        const angleRad = Math.atan2(dy, dx);\n        const xVelocity = speedPerSec * Math.cos(angleRad);\n        const yVelocity = speedPerSec * Math.sin(angleRad);\n\n        this.translate(xVelocity, yVelocity);\n        this.rotateToAngleRad(angleRad);\n\n        this.frontCollider.translate(xVelocity, yVelocity);\n        this.frontCollider.rotateToAngleRad(angleRad);\n\n        this.angleRad = angleRad;\n\n        return remainingSpeed - speedPerSec;\n    }\n\n    /**\n     * Move vehicle along path.\n     * @param {number} tickMillisec\n     * @param {TravelGraph} travelGraph\n     * @param {RoadTileMatrix} roadTileMatrix\n     * @param {function} addVehicleToInsct\n     */\n    step(tickMillisec, travelGraph, roadTileMatrix, addVehicleToInsct) {\n        // No where else to go\n        if (this.path.length === 0) {\n            this.setRandomPath(travelGraph);\n        }\n\n        let targetNode = travelGraph.getNode(this.path[0])\n        let remainingSpeed = this.speedPerSec * (tickMillisec / 1000);\n\n        while (!this.waitingAtInsct && remainingSpeed > 0) {\n            // Prevent glitch where a vehicle will rotate unusually after\n            // approaching its target node and starting a new path.\n            if (this.prevTargetId !== targetNode.id) {\n                // Move vehicle towards target\n                remainingSpeed = this._moveTowardsTarget(remainingSpeed, targetNode);\n            }\n\n            if (this.centerX === targetNode.x && this.centerY === targetNode.y) {\n                this.prevTargetId = parseInt(this.path.shift());\n\n                // Repopulate path if exhausted\n                if (this.path.length === 0) {\n                    this.setRandomPath(travelGraph);\n                }\n\n                const prevTarget = travelGraph.getNode(this.prevTargetId);\n                if (this._atInsct(roadTileMatrix, prevTarget)) {\n                    addVehicleToInsct(this, prevTarget);\n                    break;\n                }\n\n                targetNode = travelGraph.getNode(this.path[0]);\n            }\n        }\n    }\n\n    /**\n     * Checks whether a given node is within an Intersection.\n     * @param {RoadTileMatrix} roadTileMatrix\n     * @param {TravelNode} travelNode Travel node that may or may not be at insct\n     */\n    _atInsct(roadTileMatrix, travelNode) {\n        const roadTile = roadTileMatrix.get(travelNode.row, travelNode.col);\n        return roadTileTypeIsIntersection(roadTile)\n            && travelNode.travelNodeType === TravelNodeType.ENTER;\n    }\n}\n\nexport function VehicleComponent(props) {\n    return (\n        <div onClick={(e) => console.log(props.vehicle)} >\n            <RectangleComponent\n                rect={props.vehicle}\n                backgroundColor={props.vehicle.color}>\n            </RectangleComponent>\n            {props.globalSettings.displayVehicleColliders ?\n                <RectangleComponent\n                    rect={props.vehicle.frontCollider}\n                    backgroundColor='#f00'>\n                </RectangleComponent>\n                : <div></div>\n            }\n        </div >\n    );\n}\n\nVehicleComponent.propTypes = {\n    globalSettings: PropTypes.object.isRequired,\n    vehicle: PropTypes.object.isRequired,\n}","export const getRandomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n};","import PropTypes from 'prop-types';\n\nimport { Intersection } from '../Intersection/Intersection';\nimport { Vehicle, VehicleComponent } from '../Vehicle/Vehicle';\n\n/**\n * Handles movement of all vehicles and intersection logic.\n */\nexport class Traffic {\n    static count = 0;\n\n    constructor(vehicles, inscts) {\n        this.vehicles = vehicles;\n        this.inscts = inscts ? inscts : {}; // intersections\n        this._addVehicleToInsct = this._addVehicleToInsct.bind(this);\n    }\n\n    /**\n     * Add Vehicle at TravelNode location.\n     * @param {TravelNode} travelNode\n     */\n    addVehicle(travelNode) {\n        const id = Traffic.count++;\n        const x = travelNode.x;\n        const y = travelNode.y;\n        const vehicle = new Vehicle(id, x, y, travelNode.id);\n        this.vehicles.push(vehicle);\n        return vehicle;\n    };\n\n    /**\n     * Returns whether Vehicle is colliding with another vehicle.\n     * @param {Vehicle} vehicle\n     * @returns Vehicle is colliding with another vehicle\n     */\n    _vehicleInCollision(vehicle) {\n        for (const i in this.vehicles) {\n            if (this.vehicles[i] !== vehicle) {\n                if (vehicle.frontCollider.collidesWith(this.vehicles[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Add vehicle to intersection.\n     * @param {Vehicle} vehicle Vehicle that has entered TravelNode of insct\n     * @param {TravelNode} travelNode TravelNode associated with insct\n     */\n    _addVehicleToInsct(vehicle, travelNode) {\n        const r = travelNode.row;\n        const c = travelNode.col;\n        const insctKey = `${r},${c}`;\n\n        if (!this.inscts.hasOwnProperty(insctKey)) {\n            this.inscts[insctKey] = new Intersection();\n        }\n        this.inscts[insctKey].enqueue(vehicle, travelNode.direction);\n        vehicle.waitingAtInsct = true;\n    }\n\n    /**\n     * Step all Vehicles.\n     * @param {number} tickMillisec\n     * @param {TravelGraph} travelGraph\n     */\n    step(tickMillisec, travelGraph, roadTileMatrix) {\n        // Step intersections\n        for (let insctKey in this.inscts) {\n            const insct = this.inscts[insctKey];\n            const dequeuedVehicle = insct.step(tickMillisec);\n            if (dequeuedVehicle) {\n                dequeuedVehicle.waitingAtInsct = false;\n            }\n        }\n\n        // Step vehicles\n        this.vehicles.forEach(vehicle => {\n            if (!this._vehicleInCollision(vehicle)) {\n                vehicle.step(\n                    tickMillisec,\n                    travelGraph,\n                    roadTileMatrix,\n                    this._addVehicleToInsct\n                );\n            }\n        });\n    }\n\n    /**\n     * Vehicle exists at given RoadTile.\n     * @param {Vehicle} vehicle\n     * @param {number} row\n     * @param {number} col\n     * @returns {boolean}\n     */\n    vehicleIn(vehicle, r, c) {\n        // Pull variables from .css\n        const style = getComputedStyle(document.documentElement);\n        const tileWidth = Number(style.getPropertyValue('--tile-width-raw'));\n        const tileHeight = Number(style.getPropertyValue('--tile-height-raw'));\n\n        const x1 = tileWidth * c;\n        const y1 = tileHeight * r;\n        const x2 = x1 + tileWidth - 1;\n        const y2 = y1 + tileHeight - 1;\n\n        return (vehicle.centerX >= x1 && vehicle.centerX <= x2\n            && vehicle.centerY >= y1 && vehicle.centerY <= y2);\n    }\n\n    /**\n     * Removes Vehicles from RoadTile at given coordinate and all neighbors.\n     * @param {number} row\n     * @param {number} col\n     * @param {Object} neighbors\n     */\n    removeVehiclesNear(r, c, neighbors) {\n        this.removeVehiclesAt(r, c);\n        for (const direction in neighbors) {\n            const [nR, nC] = neighbors[direction].coords;\n            this.removeVehiclesAt(nR, nC);\n        }\n    }\n\n    /**\n     * Removes Vehicles from RoadTile at given coordinate.\n     * @param {number} row\n     * @param {number} col\n     */\n    removeVehiclesAt(r, c) {\n        this.vehicles = this.vehicles.filter(vehicle =>\n            !this.vehicleIn(vehicle, r, c)\n        );\n    }\n\n    /**\n     * Randomize path of all Vehicles using current TravelGraph state.\n     * @param {TravelGraph} travelGraph\n     */\n    rerandomizeAllVehiclePaths(travelGraph) {\n        this.vehicles.forEach(vehicle => {\n            vehicle.resetRandomPath(travelGraph);\n        });\n    }\n}\n\nexport function TrafficComponent(props) {\n    return (\n        <div>\n            {props.traffic.vehicles.map(vehicle =>\n                <VehicleComponent\n                    key={`vehicle-component${vehicle.id}`}\n                    globalSettings={props.globalSettings}\n                    vehicle={vehicle} />\n            )}\n        </div>\n    );\n}\n\nTrafficComponent.propTypes = {\n    globalSettings: PropTypes.object.isRequired,\n    traffic: PropTypes.object.isRequired,\n}\n","import React, { useEffect, useState } from 'react'\nimport PropTypes from 'prop-types';\n\nimport { RoadTileMatrix, Grid } from '../Grid/Grid';\nimport { Traffic, TrafficComponent } from '../Traffic/Traffic';\nimport { TravelGraph, TravelGraphComponent } from '../TravelGraph/TravelGraph';\n\n/**\n * Main component for controlling the flow of the simulation.\n * @param {Object} props\n */\nexport function RoadNetwork(props) {\n    const [roadTileMatrix, setRoadTileMatrix] = useState(\n        new RoadTileMatrix(props.rows, props.cols, null)\n    )\n    const [travelGraph, setTravelGraph] = useState(\n        new TravelGraph(null, null, null)\n    )\n    const [traffic, setTraffic] = useState(\n        new Traffic([], {})\n    )\n    const [lastTimeMillisec, setLastTimeMillisec] = useState(Date.now());\n\n    // Initialize step interval\n    useEffect(() => {\n        const intervalId = setInterval(() => {\n            if (!document.hidden) {\n                step();\n            } else {\n                setLastTimeMillisec(Date.now());\n            }\n        }, 16); // ~30fps\n        return () => clearInterval(intervalId);\n    });\n\n    /**\n     * Step Components in the road network a set amount of milliseconds.\n     */\n    function step() {\n        const curTimeMillisec = Date.now();\n        const tickMillisec = curTimeMillisec - lastTimeMillisec;\n        traffic.step(tickMillisec, travelGraph, roadTileMatrix);\n\n        // Force any re-renders from changed Traffic\n        const newTraffic = new Traffic(traffic.vehicles, traffic.inscts);\n        setTraffic(newTraffic);\n\n        setLastTimeMillisec(curTimeMillisec);\n    }\n\n    /**\n     * Add road and randomly generate vehicles.\n     * @param {number} row\n     * @param {number} col\n     * @param {boolean} restrictToNeighbors\n     */\n    function addRoad(r, c, restrictToNeighbors) {\n        // Try to add tile\n        const tileAdded = roadTileMatrix.addTile(r, c, restrictToNeighbors);\n        if (!tileAdded) {\n            return;\n        }\n\n        // Update graph\n        const roadTileType = roadTileMatrix.get(r, c);\n        const neighbors = roadTileMatrix.getNeighbors(r, c);\n        travelGraph.registerTravelIntersection(r, c, roadTileType, neighbors);\n\n        // Add vehicle to newest node with random chance\n        if (Math.floor(Math.random() * 100) < 40) {\n            const newestNode = travelGraph.getNewestNode();\n            if (newestNode) {\n                traffic.addVehicle(newestNode);\n            }\n        }\n\n        // Prevents strange behavior where vehicle could otherwise travel\n        // across TravelGraph edges that no longer exist.\n        traffic.rerandomizeAllVehiclePaths(travelGraph);\n\n        rerender();\n    }\n\n    /**\n     * Remove road and nearby vehicles.\n     * @param {number} r\n     * @param {number} c\n     */\n    function removeRoad(r, c) {\n        if (!roadTileMatrix.tileCanBeRemoved(r, c)) {\n            return;\n        }\n\n        const neighbors = roadTileMatrix.getNeighbors(r, c);\n\n        // Remove nearby vehicles\n        traffic.removeVehiclesNear(r, c, neighbors);\n\n        // Update graph\n        travelGraph.unregisterTravelIntersection(r, c, neighbors);\n\n        // Prevents error where vehicle could otherwise travel to TravelGraph\n        // nodes that no longer exist.\n        traffic.rerandomizeAllVehiclePaths(travelGraph);\n\n        // Try to remove tile\n        const tileRemoved = roadTileMatrix.removeTile(r, c);\n        if (!tileRemoved) {\n            return;\n        }\n\n        rerender();\n    }\n\n    /**\n     * Force rerender of any changed Components.\n     */\n    function rerender() {\n        const newRoadTileMatrix = new RoadTileMatrix(\n            props.rows,\n            props.cols,\n            roadTileMatrix.innerArray\n        );\n        setRoadTileMatrix(newRoadTileMatrix);\n\n        const graph = travelGraph.graph;\n        const nodes = travelGraph.nodes;\n        const intersections = travelGraph.intersections;\n        const newTravelGraph = new TravelGraph(graph, nodes, intersections);\n        setTravelGraph(newTravelGraph);\n\n        const newTraffic = new Traffic(traffic.vehicles, traffic.inscts);\n        setTraffic(newTraffic);\n    }\n\n    return (\n        <div>\n            <Grid\n                globalSettings={props.globalSettings}\n                roadTileMatrix={roadTileMatrix}\n                addRoad={addRoad}\n                removeRoad={removeRoad} />\n            <TravelGraphComponent\n                globalSettings={props.globalSettings}\n                travelGraph={travelGraph} />\n            <TrafficComponent\n                globalSettings={props.globalSettings}\n                traffic={traffic}\n            />\n        </div>\n    );\n}\n\nRoadNetwork.propTypes = {\n    globalSettings: PropTypes.object.isRequired,\n    rows: PropTypes.number.isRequired,\n    cols: PropTypes.number.isRequired,\n}","import PropTypes from 'prop-types';\n\nexport function GlobalSettingsForm(props) {\n\n    const handleDisplayRoadTileDescriptorsChanged = (e) => {\n        props.setDisplayRoadTileDescriptors(e.target.checked);\n    }\n\n    const handleDisplayTravelEdgesChanged = (e) => {\n        props.setDisplayTravelEdges(e.target.checked);\n    }\n\n    const handleDisplayVehicleCollidersChanged = (e) => {\n        props.setDisplayVehicleColliders(e.target.checked);\n    }\n\n    return (\n        <div>\n            <p>Debug Settings:</p>\n            <form>\n                <input\n                    type=\"checkbox\"\n                    id=\"road-tile-descriptors\"\n                    name=\"road-tile-descriptors\"\n                    onChange={handleDisplayRoadTileDescriptorsChanged}\n                >\n                </input>\n                <label htmlFor=\"road-tile-descriptors\">Tile Descriptors</label>\n                <br />\n                <input\n                    type=\"checkbox\"\n                    id=\"travel-edges\"\n                    name=\"travel-edges\"\n                    onChange={handleDisplayTravelEdgesChanged}\n                >\n                </input>\n                <label htmlFor=\"travel-edges\">Travel Edges</label>\n                <br />\n                <input\n                    type=\"checkbox\"\n                    id=\"vehicle-colliders\"\n                    name=\"vehicle-colliders\"\n                    onChange={handleDisplayVehicleCollidersChanged}\n                >\n                </input>\n                <label htmlFor=\"vehicle-colliders\">Vehicle Colliders</label>\n            </form>\n        </div>\n    );\n}\n\nGlobalSettingsForm.propTypes = {\n    setDisplayRoadTileDescriptors: PropTypes.func.isRequired,\n    setDisplayTravelEdges: PropTypes.func.isRequired,\n    setDisplayVehicleColliders: PropTypes.func.isRequired,\n}","import { useState } from 'react';\n\nimport './App.css';\nimport { RoadNetwork } from './Components/RoadNetwork/RoadNetwork';\nimport { GlobalSettingsForm } from './settings/GlobalSettingsForm';\n\n// For now, make sure to update with common.css\nconst rows = 10;\nconst cols = 25;\n\nfunction App() {\n  const [globalSettings, setGlobalSettings] = useState({\n    displayRoadTileDescriptors: false,\n    displayTravelEdges: false,\n    displayVehicleColliders: false,\n  });\n\n  const setDisplayRoadTileDescriptors = (displayRoadTileDescriptors) => {\n    setGlobalSettings({\n      ...globalSettings,\n      displayRoadTileDescriptors,\n    });\n  }\n\n  const setDisplayTravelEdges = (displayTravelEdges) => {\n    setGlobalSettings({\n      ...globalSettings,\n      displayTravelEdges,\n    });\n  }\n\n  const setDisplayVehicleColliders = (displayVehicleColliders) => {\n    setGlobalSettings({\n      ...globalSettings,\n      displayVehicleColliders,\n    })\n  }\n\n  return (\n    <div className=\"App\">\n      <RoadNetwork\n        globalSettings={globalSettings}\n        rows={rows}\n        cols={cols} />\n      <GlobalSettingsForm\n        setDisplayRoadTileDescriptors={setDisplayRoadTileDescriptors}\n        setDisplayTravelEdges={setDisplayTravelEdges}\n        setDisplayVehicleColliders={setDisplayVehicleColliders}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}